package ebi.ac.uk.coroutines

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext
import java.time.Duration
import java.time.Duration.ofMillis

private const val DEFAULT_INTERVAL = 300L
val FOREVER = Duration.ofMillis(Long.MAX_VALUE)

suspend fun waitUntil(
    timeout: Duration,
    checkInterval: Duration = ofMillis(DEFAULT_INTERVAL),
    conditionEvaluator: suspend () -> Boolean,
) {
    /**
     * Wait until the given condition is complete. Function use specific context as test context generated by runTest
     * function does not wait for delay operation as "time" move faster.
     */
    suspend fun waitUntil(
        conditionEvaluator: suspend () -> Boolean,
        available: Long,
        interval: Long,
    ) {
        withContext(Dispatchers.Default) {
            require(available >= interval) { "Await condition expired" }
            val result = runCatching { conditionEvaluator() }.getOrElse { false }
            if (result.not()) {
                delay(interval)
                waitUntil(conditionEvaluator, available - interval, interval)
            }
        }
    }

    waitUntil(conditionEvaluator, available = timeout.toMillis(), checkInterval.toMillis())
}
