package ebi.ac.uk.coroutines

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext
import mu.KotlinLogging
import java.time.Duration
import java.time.Duration.ofMillis

private const val DEFAULT_INTERVAL = 300L
private val logger = KotlinLogging.logger {}

val FOREVER: Duration = ofMillis(Long.MAX_VALUE)

/**
 * Wait until the given condition is met. It will succeed if the given function returns true and will fail either if the
 * given function returns false or there's an exception in the execution.
 */
suspend fun waitUntil(
    timeout: Duration,
    checkInterval: Duration = ofMillis(DEFAULT_INTERVAL),
    conditionEvaluator: suspend () -> Boolean,
) {
    /**
     * Function use specific context as test context generated by runTest function does not wait for delay operation as
     * "time" move faster.
     */
    suspend fun waitUntil(
        conditionEvaluator: suspend () -> Boolean,
        available: Long,
        interval: Long,
    ) {
        withContext(Dispatchers.Default) {
            require(available >= interval) { "Await condition expired" }
            val result = runCatching { conditionEvaluator() }.getOrElse { false }
            if (result.not()) {
                delay(interval)
                waitUntil(conditionEvaluator, available - interval, interval)
            }
        }
    }

    waitUntil(conditionEvaluator, available = timeout.toMillis(), checkInterval.toMillis())
}

/**
 * Wait for the given function to be completed. It will fail only if there's an exception in the execution of the given
 * function.
 */
suspend fun waitForCompletion(
    timeout: Duration,
    checkInterval: Duration = ofMillis(DEFAULT_INTERVAL),
    function: suspend () -> Unit,
) {
    /**
     * Function use specific context as test context generated by runTest function does not wait for delay operation as
     * "time" move faster.
     */
    suspend fun waitUntil(
        function: suspend () -> Unit,
        available: Long,
        interval: Long,
    ) {
        withContext(Dispatchers.Default) {
            require(available >= interval) { "Await condition expired" }
            val result = runCatching { function() }
            if (result.isFailure) {
                var exception = result.exceptionOrNull()
                logger.error(exception) { "exception evaluating condition {${exception?.message}}" }
                delay(interval)
                waitUntil(function, available - interval, interval)
            }
        }
    }

    waitUntil(function, available = timeout.toMillis(), checkInterval.toMillis())
}
